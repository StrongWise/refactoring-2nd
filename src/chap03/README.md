chapter.3 코드에서 나는 악취
====

## table of contents
1. [기이한 이름](#기이한-이름)
2. [중복 코드](#중복-코드)
3. [긴 함수](#긴-함수)
4. [긴 매개변수 목록](#긴-매개변수-목록)
5. [전역 데이터](#전역-데이터)
6. [가변 데이터](#가변-데이터)
7. [뒤엉킨 변경](#뒤엉킨-변경)
8. [산탄총 수술](#산탄총-수술)
9. [기능 편애](#기능-편애)
10. [데이터 뭉치](#데이터-뭉치)
11. [기본형 집착](#기본형-집착)
12. [반복되는 switch문](#반복되는-switch문)
13. [반복문](#반복문)
14. [성의 없는 요소](#성의-없는-요소)
15. [추측성 일반화](#추측성-일반화)
16. [임시 필드](#임시-필드)
17. [메시지 체인](#메시지-체인)
18. [중개자](#중개자)
19. [내부자 거래](#내부자-거래)
20. [거대한 클래스](#거대한-클래스)
21. [서로 다른 인터페이스의 대안 클래스들](#서로-다른-인터페이스의-대안-클래스들)
22. [데이터 클래스](#데이터-클래스)
23. [상속 포기](#상속-포기)
24. [주석](#주석)

---

## 기이한 이름
- 단순 명료한 이름을 작성해야 한다. __함수 선언 바꾸기__, __변수 이름 바꾸기__, __필드 이름 바꾸기__ 같은 리팩터링을 사용한다.

## 중복 코드
- 같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여야 한다. __함수 추출하기__, __문장 슬라이드__ 로 비슷한 부분을 모아보기, __메서드 올리기__ 같은 리팩터링 기법을 사용한다.

## 긴 함수
- 긴 함수를 짧은 함수로 쪼개어 코드를 이해하고, 공유하고, 선택하기 쉽게 만든다.
- __함수 추출하기__ 를 주로 사용하는데, 매개변수와 임시 변수가 많으면 __임시 변수를 질의 함수로 바꾸기__, __매개변수 객체 만들기__, __객체 통쨰로 넘기기__ 를 활용한다.
- 조건문은 __조건문 분해하기__, 반복문은 __반복문 쪼개기__, switch문은 case문 마다 __함수 추출하기__ 또는 __조건부 로직을 다형성으로 바꾸기__ 를 적용한다.

## 긴 매개변수 목록
- 매개변수에서 값을 얻어올 수 있는 매개변수가 있으면 __매개변수를 질의 함수로 바꾸기__
- 데이터 구조에서 값들을 뽑아 각각 별개의 매개변수로 전달하는 경우 __객체 통쨰로 넘기기__
- 항상 같이 전달되는 매개변수들은 __매개변수 객체 만들기__
- 플래그 역할 매개변수는 __플래그 인수 제거하기__
- 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용하면 __여러 함수를 클래스로 묶기__

## 전역 데이터
- 코드베이스 어디서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없기 때문에 이를 방지하기 위해 __변수 캡슐화하기__, 접근 범위를 최소로 줄이기

## 가변 데이터
- 무분별한 데이터 수정에 따른 위험을 줄여야 한다.
- __변수 캡슐화하기__ 를 통해 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 한다.
- 하나의 변수에 용도가 다른 값들을 저장해야 한다면 __변수 쪼개기__ 를 이용해 용도별로 독립 변수에 저장한다.
- __문장 슬라이드하기__, __함수 추출하기__ 로 갱신 로직은 다른 코드와 떨어뜨려 놓는다.
- API 작성시 __질의 함수와 변경 함수 분리하기__
- 변수의 유효범위를 줄이기 위해 __세터 제거하기__
- 값을 다른 곳에서 설정할 수 있는 가변 데이터가 있으면 __파생 변수를 질의 함수로 바꾸기__
- __여러 함수를 클래스로 묶기__ 나 __여러 함수를 변환 함수로 묶기__ 로 변수를 갱신하는 코드의 유효범위를 제한한다.
- 내부 필드에 데이터를 담고 있는 변수라면 __참조를 값을 바꾸기__ 를 적용하여 구조체를 통쨰로 교체한다.

## 뒤엉킨 변경
- 단일 책임 원칙(SRP: 단일 모듈은 변경의 이유가 하나여야한다)이 제대로 지켜지지 않을 때 나타난다. (하나의 모듈이 서로 다른 이유로 변경될 경우)
- 순차적으로 실행되는게 자연스러운 맥락이라면 __단계 쪼개기__ 로 맥락별로 분리한다.

## 산탄총 수술
- 변경할 부분이 코드 전반에 퍼져있다면 __여러 함수를 클래스로 묶기__, __여러 함수를 변환 함수로 묶기__ 로 한 모듈에 묶어두면 좋다.

## 기능 편애
- 프로그램을 모듈화 할 때 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고, 영역 사이에서 이뤄지는 상호작용은 최소로 줄인다.

## 데이터 뭉치
- 데이터 항목들이 여러 곳에서 뭉쳐 다닐 때 __클래스 추출하기__ 로 하나의 객체로 묶는다.
- 메서드 시그니처에 있는 데이터 뭉치는 __매개변수 객체 만들기__, __객체 통쨰로 넘기기__ 로 매개변수를 줄인다.

## 기본형 집착
- 날짜, 화폐, 좌표, 구간, 금액, 물리량(단위가 필요한), 전화번호 등 기본형을 사용하는 것보다 __기본형을 객체로 바꾸기__ 를 적용하자.
- 조건부 동작을 제어하는 타입 코드를 쓰이는 기본형은 __타입 코드를 서브클래스로 바꾸기__, __조건부 로직을 다형성으로 바꾸기__ 를 적용한다.

## 반복되는 switch문
- 조건절을 하나 추가할 때 마다 다른 switch 문들도 모두 찾아서 함께 수정해야 하기 떄문에 __조건부 로직을 다형성으로 바꾸기__ 를 적용한다.

## 반복문
- __반복문을 파이프라인으로 바꾸기__ 를 적용하여 filter나 map 같은 파이프라인 연산을 사용하자.

## 성의 없는 요소
- 메서드, 클래스, 인터페이스 등 코드 구조를 잡기 위해 만든 요소들은 __함수 인라인하기__, __클래스 인라인하기__, __계층 합치기__ 를 적용한다.

## 추측성 일반화
- 당장은 필요없는 모든 종류의 코드는 __죽은 코드 제거하기__ 로 날려버리자

## 임시 필드
- 특정 상황에서만 값이 설정되는 필드들은 __클래스 추출하기__ 로 제 살 곳을 찾아주고, __함수 옮기기__ 로 새 클래스에 몰아넣는다.

## 메시지 체인
- 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드는 __위임 숨기기__ 로 해결한다.
  ```javascript
    managerName = aPerson.department.manager.name;
    managerName = aPerson.department.managerName; // 관리자 객체의 존재를 숨김
    managerName = aPerson.manager.name; // 부서 객체의 존재를 숨김
    managerName = aPerson.managerName; // 부서, 관리자 객체의 존재를 숨김
  ```

## 중개자
- 외부로부터 세부사항을 숨겨주는 캡슐화하는 과정에서 위임이 자주 활용되는데, 지나치면 독이 된다. __중개자 제거하기__ 를 적용하자.

## 내부자 거래
- 모듈 사이 데이터 거래가 많으면 결합도가 높아지므로 그 양을 최소로 줄이고 투명하게 처리해야 한다. 사적으로 처리하는 부분을 줄이고, 여러 모듈이 같은 관심사를 공유하면 제3의 모듈을 만들거나 __위임 숨기기__ 로 중간자 역할을 하게 만든다.

## 거대한 클래스
- 한 클래스가 너무 많은 일을 하려다 보면 필드 수가 늘어나고 중복 코드가 생기기 쉽다.
- __클래스 추출하기__ 로 필드를 따로 묶고, 원래 클래스와 상속관계로 만드는게 좋다면 __슈퍼클래스 추출하기__, __타입 코드를 서브클래스로 바꾸기__ 를 적용한다.

## 서로 다른 인터페이스의 대안 클래스들
- 클래스를 다른 클래스로 교체 할 때 인터페이스가 같아야 하므로 __함수 선언 바꾸기__ 로 메서드 시그니처를 일치시키고 인터페이스가 같아질 때까지 필요한 동작들을 가져온다. 대안 클래스들 사이에 중복이 생기면 __슈퍼클래스 추출하기__ 를 적용할지 고려해본다.

## 데이터 클래스
- getter/setter 메서드로만 구성된 클래스로 이런 클래스에 public 필드가 있다면 __레코드 캡슐화하기__ 로 숨기고, 변경하면 안되는 필드는 __세터 제거하기__ 로 접근을 막는다.
- 불변 필드는 굳이 캡슐화할 필요 없고 공개해도 상관 없다.

## 상속 포기
- 서브 클래스는 부모로부터 메서드와 데이터를 물려받는데, 부모의 유산이 필요가 없다면 __서브클래스를 위임으로 바꾸기__ 나 __슈퍼클래스를 위임으로 바꾸기__ 로 상속에서 벗어나자.

## 주석
- 특정 코드 블록이 하는 일을 주석에 남기고 싶다면 __함수 추출하기__ 를 적용해 본다.
- 이미 추출되어 있는 함수임에도 여전히 설명이 필요하다면 __함수 선언 바꾸기__ 로 함수 이름을 바꿔본다.
- 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 __어서션 추가하기__ 를 하자.
> 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.
